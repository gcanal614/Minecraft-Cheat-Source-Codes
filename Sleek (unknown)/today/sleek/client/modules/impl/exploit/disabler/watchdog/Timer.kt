package today.sleek.client.modules.impl.exploit.disabler.watchdog

import e
import net.minecraft.network.Packet
import net.minecraft.network.play.INetHandlerPlayServer
import net.minecraft.network.play.client.C00PacketKeepAlive
import net.minecraft.network.play.client.C03PacketPlayer
import net.minecraft.network.play.client.C0FPacketConfirmTransaction
import today.sleek.base.event.PacketDirection
import today.sleek.base.event.impl.PacketEvent
import today.sleek.base.event.impl.UpdateEvent
import today.sleek.client.modules.impl.exploit.disabler.DisablerMode
import today.sleek.client.utils.chat.ChatUtil
import today.sleek.client.utils.math.Stopwatch
import today.sleek.client.utils.moshi.IPacketUtils
import today.sleek.client.utils.network.PacketUtil
import today.sleek.client.utils.network.TimedPacket


/**
 * @author Kansio
 */
class Timer : DisablerMode("Watchdog Timer"), IPacketUtils {

    private val delay: Stopwatch = Stopwatch()

    val packets = ArrayList<TimedPacket>()
    override fun onEnable() {

    }

    override fun onUpdate(event: UpdateEvent) {
        if (mc.thePlayer.ticksExisted < 5) {
            packets.clear()
            delay.resetTime()
        }
        val packetz = ArrayList<TimedPacket>()
        for (packet in packets) {
            if (packet.postAddTime() > 4000) {
                ChatUtil.log("sending ${packet.packet.javaClass.simpleName}")
                packet.sendSilent()
                packetz.add(packet)
            }
        }
        packets.removeIf { p -> packetz.contains(p) }
    }

    override fun onPacket(event: PacketEvent) {
        if (event.isSending) {
            if (!delay.timeElapsed(4000)) {
                packets.add(create(event.getPacket()))
            }
        }
    }
}
