// 
// Decompiled by Procyon v0.5.36
// 

package vip.Resolute.modules.impl.exploit;

import net.minecraft.util.AxisAlignedBB;
import java.util.Iterator;
import net.minecraft.client.entity.EntityPlayerSP;
import net.minecraft.network.play.server.S08PacketPlayerPosLook;
import vip.Resolute.events.impl.EventPacket;
import net.minecraft.network.play.client.C03PacketPlayer;
import vip.Resolute.events.impl.EventMotion;
import net.minecraft.entity.Entity;
import vip.Resolute.events.impl.EventMove;
import vip.Resolute.events.Event;
import vip.Resolute.settings.Setting;
import java.util.ArrayList;
import net.minecraft.network.Packet;
import java.util.List;
import vip.Resolute.settings.impl.NumberSetting;
import vip.Resolute.settings.impl.ModeSetting;
import vip.Resolute.modules.Module;

public class AntiVoid extends Module
{
    public ModeSetting mode;
    public NumberSetting distance;
    public NumberSetting bounceHeight;
    double oldy;
    double oldx;
    double oldz;
    private boolean needJump;
    private double lastY;
    private double x;
    private double y;
    private double z;
    private boolean falling;
    private List<Packet> packets;
    private boolean canSpoof;
    private double lastRecY;
    
    public boolean isModeSelected() {
        return this.mode.is("Bounce");
    }
    
    public AntiVoid() {
        super("AntiFall", 0, "Lags you out of the void", Category.EXPLOIT);
        this.mode = new ModeSetting("Mode", "Watchdog", new String[] { "Vanilla", "Watchdog", "Position", "Jump", "Bounce", "Jartex" });
        this.distance = new NumberSetting("Distance", 6.0, 4.0, 15.0, 1.0);
        this.bounceHeight = new NumberSetting("Bounce Height", 1.1, this::isModeSelected, 0.1, 5.0, 0.1);
        this.needJump = false;
        this.lastY = 0.0;
        this.packets = new ArrayList<Packet>();
        this.canSpoof = false;
        this.lastRecY = 0.0;
        this.addSettings(this.mode, this.distance, this.bounceHeight);
    }
    
    @Override
    public void onEvent(final Event e) {
        if (e instanceof EventMove) {
            final EventMove event = (EventMove)e;
            if (this.mode.is("Bounce")) {
                if (AntiVoid.mc.thePlayer.fallDistance >= this.distance.getValue() && AntiVoid.mc.thePlayer.motionY <= 0.0 && (!this.needJump || AntiVoid.mc.thePlayer.posY <= this.lastY) && AntiVoid.mc.theWorld.getCollidingBoundingBoxes(AntiVoid.mc.thePlayer, AntiVoid.mc.thePlayer.getEntityBoundingBox().offset(0.0, 0.0, 0.0).expand(0.0, 0.0, 0.0)).isEmpty() && AntiVoid.mc.theWorld.getCollidingBoundingBoxes(AntiVoid.mc.thePlayer, AntiVoid.mc.thePlayer.getEntityBoundingBox().offset(0.0, -10002.25, 0.0).expand(0.0, -10003.75, 0.0)).isEmpty()) {
                    AntiVoid.mc.thePlayer.motionY = this.bounceHeight.getValue();
                    event.setX(0.0);
                    event.setZ(0.0);
                    this.lastY = AntiVoid.mc.thePlayer.posY;
                    this.needJump = true;
                }
                if (AntiVoid.mc.thePlayer.onGround) {
                    this.lastY = 0.0;
                    this.needJump = false;
                }
            }
        }
        if (e instanceof EventMotion) {
            final EventMotion event2 = (EventMotion)e;
            if (this.mode.is("Vanilla")) {
                if (AntiVoid.mc.thePlayer.onGround) {
                    this.oldx = AntiVoid.mc.thePlayer.posX;
                    this.oldy = AntiVoid.mc.thePlayer.posY;
                    this.oldz = AntiVoid.mc.thePlayer.posZ;
                }
                else if (AntiVoid.mc.thePlayer.fallDistance >= this.distance.getValue() && AntiVoid.mc.thePlayer.ticksExisted % 5 == 0 && !isBlockUnder()) {
                    AntiVoid.mc.thePlayer.setPosition(this.oldx, this.oldy, this.oldz);
                }
            }
            if (this.mode.is("Jartex")) {
                this.canSpoof = false;
                if (AntiVoid.mc.theWorld.getCollidingBoundingBoxes(AntiVoid.mc.thePlayer, AntiVoid.mc.thePlayer.getEntityBoundingBox().offset(0.0, 0.0, 0.0).expand(0.0, 0.0, 0.0)).isEmpty() && AntiVoid.mc.theWorld.getCollidingBoundingBoxes(AntiVoid.mc.thePlayer, AntiVoid.mc.thePlayer.getEntityBoundingBox().offset(0.0, -282.25, 0.0).expand(0.0, -283.75, 0.0)).isEmpty()) {
                    if (AntiVoid.mc.thePlayer.fallDistance > this.distance.getValue() && AntiVoid.mc.thePlayer.posY < this.lastRecY + 0.01 && AntiVoid.mc.thePlayer.motionY <= 0.0 && !AntiVoid.mc.thePlayer.onGround) {
                        AntiVoid.mc.thePlayer.motionY = 0.0;
                        final EntityPlayerSP thePlayer = AntiVoid.mc.thePlayer;
                        thePlayer.motionZ *= 0.838;
                        final EntityPlayerSP thePlayer2 = AntiVoid.mc.thePlayer;
                        thePlayer2.motionX *= 0.838;
                        this.canSpoof = true;
                    }
                    else if (AntiVoid.mc.thePlayer.posY > this.lastRecY + 0.01) {
                        AntiVoid.mc.thePlayer.fallDistance = 0.0f;
                    }
                }
                this.lastRecY = AntiVoid.mc.thePlayer.posY;
            }
            if (e.isPre() && this.mode.is("Blink")) {
                if (isBlockUnder() && AntiVoid.mc.thePlayer.isCollidedVertically && AntiVoid.mc.thePlayer.onGround) {
                    this.x = AntiVoid.mc.thePlayer.posX;
                    this.y = AntiVoid.mc.thePlayer.posY;
                    this.z = AntiVoid.mc.thePlayer.posZ;
                }
                if (this.falling && AntiVoid.mc.thePlayer.fallDistance > this.distance.getValue()) {
                    this.packets.clear();
                    AntiVoid.mc.thePlayer.setPositionAndUpdate(this.x, this.y, this.z);
                    event2.setX(this.x);
                    event2.setY(this.y);
                    event2.setZ(this.z);
                }
            }
            if (this.mode.is("Position") && AntiVoid.mc.thePlayer.fallDistance >= this.distance.getValue() && !isBlockUnder()) {
                AntiVoid.mc.thePlayer.setPosition(AntiVoid.mc.thePlayer.posX, AntiVoid.mc.thePlayer.posY + 1.0, AntiVoid.mc.thePlayer.posZ);
            }
            if (this.mode.is("Jump") && AntiVoid.mc.thePlayer.fallDistance >= this.distance.getValue() && !isBlockUnder()) {
                AntiVoid.mc.thePlayer.jump();
            }
            if (this.mode.is("Watchdog") && AntiVoid.mc.thePlayer.fallDistance >= this.distance.getValue() && !isBlockUnder()) {
                AntiVoid.mc.getNetHandler().getNetworkManager().sendPacket(new C03PacketPlayer.C04PacketPlayerPosition(AntiVoid.mc.thePlayer.posX, AntiVoid.mc.thePlayer.posY + 12.0, AntiVoid.mc.thePlayer.posZ, false));
                AntiVoid.mc.thePlayer.fallDistance = 0.0f;
            }
        }
        if (e instanceof EventPacket) {
            if (this.mode.is("Jartex") && this.canSpoof && ((EventPacket)e).getPacket() instanceof C03PacketPlayer) {
                final C03PacketPlayer packetPlayer = ((EventPacket)e).getPacket();
                packetPlayer.onGround = true;
            }
            if (this.mode.is("Blink")) {
                if (((EventPacket)e).getPacket() instanceof C03PacketPlayer) {
                    final C03PacketPlayer cpacket = ((EventPacket)e).getPacket();
                    if (!isBlockUnder()) {
                        this.packets.add(cpacket);
                        e.setCancelled(true);
                        this.falling = true;
                    }
                    else if (AntiVoid.mc.thePlayer.fallDistance < this.distance.getValue() && this.falling) {
                        try {
                            for (final Packet packet : this.packets) {
                                AntiVoid.mc.getNetHandler().getNetworkManager().sendPacket(packet);
                            }
                        }
                        catch (Exception ex) {
                            ex.printStackTrace();
                        }
                        this.packets.clear();
                        this.falling = false;
                    }
                }
                if (((EventPacket)e).getPacket() instanceof S08PacketPlayerPosLook) {
                    final S08PacketPlayerPosLook posLook = ((EventPacket)e).getPacket();
                    for (final Packet packet : this.packets) {
                        final C03PacketPlayer packetPlayer2 = (C03PacketPlayer)packet;
                        if (packetPlayer2.getPositionX() == posLook.getX() && packetPlayer2.getPositionY() == posLook.getY() && packetPlayer2.getPositionZ() == posLook.getZ()) {
                            this.packets.clear();
                            this.falling = false;
                        }
                    }
                }
            }
        }
    }
    
    public static boolean isBlockUnder() {
        for (int offset = 0; offset < AntiVoid.mc.thePlayer.posY + AntiVoid.mc.thePlayer.getEyeHeight(); offset += 2) {
            final AxisAlignedBB boundingBox = AntiVoid.mc.thePlayer.getEntityBoundingBox().offset(0.0, -offset, 0.0);
            if (!AntiVoid.mc.theWorld.getCollidingBoundingBoxes(AntiVoid.mc.thePlayer, boundingBox).isEmpty()) {
                return true;
            }
        }
        return false;
    }
}
